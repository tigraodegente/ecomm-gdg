---
import Layout from '../../layouts/Layout.astro';
import MarketplaceLayout from '../../layouts/MarketplaceLayout.astro';
import ProductCard from '../../components/ui/ProductCard.astro';
import Rating from '../../components/ui/Rating.astro';
import Filters from '../../components/ui/Filters.astro';
import SimplifiedFilters from '../../components/ui/SimplifiedFilters.astro';
import categoryService from '../../services/categoryService';
import productService from '../../services/productService';

// Pegar parâmetros da URL
const { searchParams } = Astro.url;
const params = Astro.url.searchParams;

// Extrair parâmetros específicos da URL
const search = params.get('q') || '';
const minPrice = params.get('minPrice') || '';
const maxPrice = params.get('maxPrice') || '';
const sort = params.get('sort') || 'newest';
const page = parseInt(params.get('page') || '1');
const limit = parseInt(params.get('limit') || '12');

// Parâmetros para filtros de categorias
const selectedCategories = params.getAll('category') || [];

// Parâmetros para filtros de atributos
const attributeFilters = {};

// Encontrar todos os parâmetros de atributos (formato: attr_ID=VALOR)
for (const [key, value] of params.entries()) {
  if (key.startsWith('attr_')) {
    const attrId = key.replace('attr_', '');
    
    if (!attributeFilters[attrId]) {
      attributeFilters[attrId] = [];
    }
    
    attributeFilters[attrId].push(value);
  }
}

// Página atual
let pageTitle = 'Todos os Produtos';

// Se tiver categorias selecionadas, usar a primeira para o título
if (selectedCategories.length > 0) {
  const firstCategory = categoryService.getCategoryByCid(selectedCategories[0]);
  if (firstCategory) {
    pageTitle = firstCategory.name;
  }
}

// Se tiver pesquisa, mostrar no título
if (search) {
  if (selectedCategories.length > 0) {
    // Busca + categoria
    const firstCategory = categoryService.getCategoryByCid(selectedCategories[0]);
    if (firstCategory) {
      pageTitle = `"${search}" em ${firstCategory.name}`;
    } else {
      pageTitle = `Resultados para "${search}"`;
    }
  } else {
    // Apenas busca
    pageTitle = `Resultados para "${search}"`;
  }
}

// Opções para listar produtos
const options = {
  search,
  minPrice: minPrice ? parseFloat(minPrice) : undefined,
  maxPrice: maxPrice ? parseFloat(maxPrice) : undefined,
  sort,
  page,
  limit,
  attributeFilters
};

// Se tiver categorias selecionadas, adicionar ao filtro
if (selectedCategories.length > 0) {
  // Listar IDs das categorias selecionadas
  const categoryIds = [];
  
  for (const slug of selectedCategories) {
    const category = categoryService.getCategoryByCid(slug);
    if (category) {
      categoryIds.push(category.id);
    }
  }
  
  if (categoryIds.length > 0) {
    options.categoryIds = categoryIds;
  }
}

// Buscar produtos com os filtros aplicados
// Se tiver busca, usar searchProducts, caso contrário usar listProducts normal
const { products, pagination } = search 
  ? productService.searchProducts(search, options) 
  : productService.listProducts(options);

// Total de itens para exibição
const totalItems = pagination.total;

// Lista de categorias ativas (apenas as que têm produtos)
const activeCategories = categoryService.getActiveCategories();

// Obter os tipos de atributos disponíveis
const attributeTypes = productService.getAttributeTypesForFilters();

// Obter os valores disponíveis para cada tipo de atributo (considerando filtros aplicados)
const attributeValues = {};
for (const attributeType of attributeTypes) {
  attributeValues[attributeType.id] = productService.getAttributeValuesForType(
    attributeType.id, 
    // Passar mesmas opções para manter consistência nos filtros
    options
  );
}

// Obter filtro de preço
const priceRanges = productService.getPriceRangesForProducts(options);

// Opções de ordenação para o dropdown
const sortOptions = [
  { value: 'newest', label: 'Mais recentes' },
  { value: 'price_asc', label: 'Menor preço' },
  { value: 'price_desc', label: 'Maior preço' },
  { value: 'name_asc', label: 'A-Z' },
  { value: 'name_desc', label: 'Z-A' },
  { value: 'featured', label: 'Destaque' }
];

// Encontrar o label da opção de ordenação ativa
const sortOptionLabel = sortOptions.find(option => option.value === sort)?.label || 'Ordenar';
---

<MarketplaceLayout title={pageTitle}>
  <Fragment slot="navbar">
    {/* Links distribuídos uniformemente */}
    <li class="w-full flex justify-between">
      {/* Todos os produtos + categorias ordenadas + links estáticos em uma única linha */}
      <a href="/produtos" class="font-medium hover:underline whitespace-nowrap">Todos os Produtos</a>
      
      {activeCategories
        .sort((a, b) => (a.display_order || 999) - (b.display_order || 999))
        .map(category => (
          <a 
            href={`/produtos?category=${category.cid}`} 
            class="hover:underline font-normal whitespace-nowrap"
          >
            {category.name}
          </a>
      ))}
      
      {categoryService.getMenuWithCategories().staticLinks.map(link => (
        <a 
          href={link.url} 
          class={`hover:underline whitespace-nowrap ${link.highlight ? 'font-medium text-[#FFEB3B]' : 'font-normal'}`}
        >
          {link.name}
        </a>
      ))}
    </li>
  </Fragment>
  <div class="min-h-screen bg-gray-100 py-12">
    <div class="container mx-auto px-1 md:px-4">
      <!-- Filtros aplicados e controles superiores -->
      <div class="mb-6">
        <!-- Navegação e contador de produtos -->
        <div class="flex flex-wrap justify-between items-center mb-3">
          <nav class="mb-4 w-full md:mb-0 md:w-auto">
            <ol class="flex items-center text-[13px]">
              <li>
                <a href="/" class="text-gray-500 hover:text-gray-700 transition-colors">Home</a>
              </li>
              <li class="flex items-center">
                <span class="mx-1 text-gray-400">/</span>
                <a href="/produtos" class="text-gray-500 hover:text-gray-700 transition-colors">Produtos</a>
              </li>
              <li class="flex items-center">
                <span class="mx-1 text-gray-400">/</span>
                <span class="text-[#39c7bb] font-medium">{pageTitle}</span>
              </li>
            </ol>
          </nav>
          
          <p class="text-sm text-gray-500">
            <span class="font-medium">{totalItems}</span> produtos encontrados
          </p>
        </div>
        
        <!-- Seção de filtros ativos com fundo branco -->
        <div class="bg-white p-3 mb-5 flex flex-wrap justify-between items-center">
          <div class="flex flex-wrap items-center gap-2">
            <span class="text-sm text-gray-800 font-medium">Filtros:</span>
            
            {/* Categorias selecionadas */}
            {selectedCategories.map(catSlug => {
              const category = categoryService.getCategoryByCid(catSlug);
              if (!category) return null;
              
              return (
                <div class="inline-flex items-center px-3 py-1.5 text-xs bg-white text-[#333333] border border-[#DDDDDD] rounded-full">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1 text-[#40C1AC]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                  </svg>
                  <span class="font-medium">{category.name}</span>
                  <a 
                    href={`/produtos?${new URLSearchParams(
                      Array.from(searchParams.entries())
                        .filter(([key, value]) => !(key === 'category' && value === catSlug))
                        .filter(([key]) => key !== 'page')
                    )}&page=1`}
                    class="ml-1.5 focus:outline-none text-[#39c7bb]"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <line x1="18" y1="6" x2="6" y2="18"></line>
                      <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                  </a>
                </div>
              );
            })}
            
            {search && (
              <div class="inline-flex items-center px-3 py-1.5 text-xs bg-white text-[#333333] border border-[#DDDDDD] rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1 text-[#40C1AC]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <span class="font-medium">Busca: {search}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('q');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {minPrice && (
              <div class="inline-flex items-center px-3 py-1.5 text-xs bg-white text-[#333333] border border-[#DDDDDD] rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1 text-[#40C1AC]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span class="font-medium">Min: R$ {minPrice}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('minPrice');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {maxPrice && (
              <div class="inline-flex items-center px-3 py-1.5 text-xs bg-white text-[#333333] border border-[#DDDDDD] rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1 text-[#40C1AC]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span class="font-medium">Max: R$ {maxPrice}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('maxPrice');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {/* Filtros de atributos ativos */}
            {Object.entries(attributeFilters).map(([typeId, values]) => {
              const attributeType = productService.getAttributeTypesForFilters().find(t => t.id.toString() === typeId);
              if (!attributeType) return null;
              
              return values.map(value => {
                // Buscar o valor de exibição para este atributo
                let displayValue = value;
                let attrValues = [];
                
                if (attributeType.name.toLowerCase().includes('material')) {
                  attrValues = productService.getMaterialsForFilter(options);
                } else if (attributeType.name.toLowerCase().includes('cor') || attributeType.name.toLowerCase().includes('color')) {
                  attrValues = productService.getColorsForFilter(options);
                } else if (attributeType.name.toLowerCase().includes('tamanho') || attributeType.name.toLowerCase().includes('size')) {
                  attrValues = productService.getSizesForFilter(options);
                }
                
                const foundValue = attrValues.find(v => v.value === value);
                if (foundValue && foundValue.display_value) {
                  displayValue = foundValue.display_value;
                }
                
                return (
                  <div class="inline-flex items-center px-3 py-1.5 text-xs bg-white text-[#333333] border border-[#DDDDDD] rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1 text-[#40C1AC]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                    </svg>
                    <span><span class="font-medium">{attributeType.display_name}:</span> {displayValue}</span>
                    <a 
                      href={(() => {
                        const url = new URL(Astro.url);
                        const currentValues = url.searchParams.getAll(`attr_${typeId}`);
                        url.searchParams.delete(`attr_${typeId}`);
                        currentValues.filter(v => v !== value).forEach(v => {
                          url.searchParams.append(`attr_${typeId}`, v);
                        });
                        return url.toString();
                      })()}
                      class="ml-1.5 focus:outline-none text-[#39c7bb]"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                      </svg>
                    </a>
                  </div>
                );
              });
            })}
            
            {(selectedCategories.length > 0 || search || minPrice || maxPrice || Object.keys(attributeFilters).length > 0) && (
              <a 
                href="/produtos" 
                class="ml-auto text-xs font-medium px-3 py-1.5 bg-white border border-[#DDDDDD] text-[#333333] rounded-full hover:bg-gray-50 transition-colors flex items-center"
              >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
                Limpar todos os filtros
              </a>
            )}
          </div>
          
          <div class="w-full md:w-auto mt-3 md:mt-0 flex items-center gap-2">
            <span class="text-sm text-gray-500 font-medium">Ordenar por:</span>
            
            <!-- Dropdown customizado com estilo mantido mas simplificado -->
            <div class="dropdown-custom relative">
              <button 
                type="button" 
                id="sort-button"
                class="text-sm min-w-[130px] appearance-none bg-white border border-[#DDDDDD] rounded-md px-3 py-2 pr-8 text-[#777777] font-medium cursor-pointer focus:outline-none focus:ring-1 focus:ring-[#DDDDDD] flex justify-between items-center"
                onclick="document.getElementById('sort-menu').classList.toggle('hidden')"
              >
                {/* Texto do botão baseado na seleção atual */}
                <span id="selected-sort-text">
                  {sort === 'newest' && 'Mais recentes'}
                  {sort === 'price_asc' && 'Menor preço'}
                  {sort === 'price_desc' && 'Maior preço'}
                  {sort === 'name_asc' && 'A-Z'}
                  {sort === 'name_desc' && 'Z-A'}
                  {sort === 'featured' && 'Destaque'}
                  {!['newest', 'price_asc', 'price_desc', 'name_asc', 'name_desc', 'featured'].includes(sort) && 'Ordenar'}
                </span>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-[#777777]">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                  </svg>
                </div>
              </button>
              
              <div 
                id="sort-menu" 
                class="absolute mt-1 w-full min-w-[160px] bg-white border border-[#DDDDDD] rounded-md shadow-lg py-1 z-30 hidden"
              >
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=newest&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'newest' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  Mais recentes
                </a>
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=price_asc&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'price_asc' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  Menor preço
                </a>
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=price_desc&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'price_desc' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  Maior preço
                </a>
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=name_asc&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'name_asc' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  A-Z
                </a>
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=name_desc&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'name_desc' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  Z-A
                </a>
                <a 
                  href={`/produtos?${new URLSearchParams([...searchParams.entries()].filter(([k]) => k !== 'sort' && k !== 'page'))}&sort=featured&page=1`}
                  class={`block px-4 py-2 text-sm hover:bg-gray-50 cursor-pointer ${sort === 'featured' ? 'bg-[#E0F7F4] text-[#40C1AC] font-medium' : 'text-[#777777]'}`}
                >
                  Destaque
                </a>
              </div>
            </div>
            
            <script>
              // Script para fechar o dropdown quando clica fora
              document.addEventListener('click', function(event) {
                const dropdown = document.querySelector('.dropdown-custom');
                const dropdownMenu = document.getElementById('sort-menu');
                const sortButton = document.getElementById('sort-button');
                
                if (dropdown && !dropdown.contains(event.target)) {
                  dropdownMenu.classList.add('hidden');
                }
              });
            </script>
            
            <!-- Botão para exibir filtros no mobile -->
            <button 
              id="toggleFilters" 
              class="md:hidden flex items-center text-sm appearance-none bg-white border border-[#DDDDDD] rounded-md px-3 py-2 text-[#333333] font-medium cursor-pointer focus:outline-none focus:ring-1 focus:ring-[#DDDDDD]"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
              </svg>
              Filtros
            </button>
          </div>
        </div>
      </div>
      
      <!-- Removido filtro simplificado para usar apenas o lateral no mobile -->
      
      <!-- Conteúdo Principal - Layout de 2 colunas no desktop -->
      <div class="flex flex-col md:flex-row gap-8">
        <!-- Overlay para mobile (visível apenas quando os filtros estiverem abertos) -->
        <div id="filtersOverlay" class="hidden fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden"></div>
        
        <!-- Filtros - Sidebar no desktop, escondida inicialmente no mobile -->
        <div id="filtersContainer" class="hidden md:block w-full md:w-[260px] md:sticky md:top-4 md:self-start">
          <div class="mb-4 relative">
            <!-- Botão fechar visível apenas no mobile -->
            <button 
              id="closeFilters" 
              class="absolute top-2 right-2 md:hidden bg-white rounded-full p-1 shadow-sm z-10"
              aria-label="Fechar filtros"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
            
            <Filters 
              search={search}
              minPrice={minPrice}
              maxPrice={maxPrice}
              selectedCategories={selectedCategories}
              selectedSort={sort}
              attributeFilters={attributeFilters}
              attributeTypes={attributeTypes}
              attributeValues={attributeValues}
              categories={activeCategories}
              priceRanges={priceRanges}
            />
          </div>
        </div>
        
        <!-- Produtos - Área principal -->
        <div class="w-full md:flex-1">
          <!-- Produtos Grid - 3 por linha no desktop, 1 no mobile com espaçamento vertical aumentado -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-x-4 gap-y-10 bg-white px-[15px] py-4 md:p-4">
            {products.length > 0 ? products.map((product) => (
              <a href={`/produto/${product.slug || product.id}`} class="block pt-7">
                <ProductCard 
                  product={{
                    id: product.id,
                    name: product.name,
                    price: product.price,
                    pricePromotional: product.compare_at_price,
                    discountPercent: product.compare_at_price && (product.compare_at_price > product.price) ? 
                      Math.round(((product.compare_at_price - product.price) / product.compare_at_price) * 100) : null,
                    pieces: product.pieces || 0,
                    material: product.material || '',
                    image: product.mainImage || null,
                    ref: product.sku || product.id.toString()
                  }}
                  showBadges={true}
                />
              </a>
            )) : (
              <div class="col-span-3 py-8 text-center">
                <p class="text-gray-500">Nenhum produto encontrado com os filtros selecionados.</p>
                <a href="/produtos" class="mt-4 inline-block text-[#39c7bb] hover:underline">Limpar filtros</a>
              </div>
            )}
          </div>
          
          <!-- Botão e indicador de carregamento para scroll infinito -->
          <div class="py-4 text-center">
            <!-- Contador de produtos -->
            <span class="text-sm text-gray-500 block mb-4">
              Mostrando <span class="font-medium" id="products-shown">{Math.min(products.length, pagination.page * pagination.limit)}</span> de <span class="font-medium">{pagination.total}</span> produtos
            </span>
            
            <!-- Botão carregar mais para caso o scroll não seja detectado -->
            {pagination.hasNextPage && (
              <button 
                type="button"
                id="load-more-btn" 
                class="mx-auto mb-4 bg-[#39c7bb] hover:bg-[#2ba090] text-white py-2 px-6 rounded-full inline-flex items-center gap-2"
                data-next-page={(page + 1).toString()}
              >
                <span>Carregar mais produtos</span>
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                </svg>
              </button>
            )}
            
            <!-- Loading indicator -->
            <div id="loading-indicator" class="py-4 flex-col items-center hidden">
              <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-[#39c7bb] mb-2"></div>
              <p class="text-gray-500 text-sm">Carregando mais produtos...</p>
            </div>
            
            <!-- Fim da lista quando todos os produtos forem carregados -->
            {!pagination.hasNextPage && products.length > 0 && (
              <div id="end-of-results" class="py-4">
                <p class="text-gray-500 text-sm">Todos os produtos foram carregados</p>
              </div>
            )}
          </div>
          
          <!-- Script para scroll infinito com AJAX (com fallback para botão) -->
          <script>
            document.addEventListener('DOMContentLoaded', function() {
              // Elementos necessários
              const loadMoreBtn = document.getElementById('load-more-btn');
              const loadingIndicator = document.getElementById('loading-indicator');
              const productsShownEl = document.getElementById('products-shown');
              const productsGrid = document.querySelector('.grid-cols-1.md\\:grid-cols-3');
              
              // Se não tiver produtos, não precisamos fazer nada
              if (!productsGrid) return;
              
              // Variáveis para controle de estado
              let isLoading = false;
              let currentPage = parseInt(new URL(window.location.href).searchParams.get('page') || '1');
              let hasNextPage = !!loadMoreBtn;
              
              // Para gerenciar a posição de scroll
              let initialScrollRestored = false;
              
              // Adicionar evento de clique ao botão de carregar mais (se existir)
              if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', function(e) {
                  e.preventDefault(); // Impedir comportamento padrão de navegação
                  loadMoreItems();
                });
              }
              
              // Variáveis para controle de scroll
              let lastScrollY = window.scrollY;
              let lastPageInView = currentPage;
              
              // Função que detecta a posição de scroll e atualiza a página atual na URL
              function checkScrollPosition() {
                // Verificar rolagem para carregar mais produtos independentemente da condição de hasNextPage
                const scrollPosition = window.scrollY + window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                // Determinar a direção do scroll
                const scrollingDown = window.scrollY > lastScrollY;
                lastScrollY = window.scrollY;
                
                // Verificar direção do scroll para lógica específica
                
                // SEMPRE calcular qual página está visível, mesmo quando carregando ou não tendo next page
                const productCards = document.querySelectorAll('.grid-cols-1.md\\:grid-cols-3 > a');
                if (productCards.length > 0) {
                  const limit = parseInt(new URL(window.location.href).searchParams.get('limit') || '12');
                  
                  // Identificar qual produto está mais próximo do topo da tela
                  let bestTopDistance = Infinity;
                  let topProduct = null;
                  
                  // Para encontrar o primeiro produto visível (ideal para rolar para cima)
                  for (const card of productCards) {
                    const rect = card.getBoundingClientRect();
                    // Para produtos acima do topo da janela, rect.top será negativo
                    // Para produtos abaixo do topo da janela, rect.top será positivo
                    // Quanto mais próximo de zero, mais próximo do topo da janela
                    
                    // Considerar apenas produtos que estão no topo ou ligeiramente acima
                    // +200px permite um pouco de margem para produtos quase visíveis no topo
                    if (rect.top <= 200) {
                      const distance = Math.abs(rect.top);
                      if (distance < bestTopDistance) {
                        bestTopDistance = distance;
                        topProduct = card;
                      }
                    }
                  }
                  
                  if (topProduct) {
                    // Determinar o índice do produto mais próximo do topo
                    const productIndex = Array.from(productCards).indexOf(topProduct);
                    
                    // Calcular em qual página este produto estaria
                    // Usamos Math.floor pois queremos a página que COMEÇA com este produto 
                    // (ou um produto anterior)
                    const pageInView = Math.max(1, Math.floor(productIndex / limit) + 1);
                    
                    // Determinar se a página mudou
                    
                    // Atualizar a URL apenas se a página mudou
                    if (pageInView !== lastPageInView) {
                      lastPageInView = pageInView;
                      
                      // Atualizar a URL sem recarregar a página
                      const url = new URL(window.location.href);
                      url.searchParams.set('page', pageInView.toString());
                      window.history.replaceState({}, '', url.toString());
                      
                      // URL atualizada para a nova página
                    }
                  }
                }
                
                // Carregar mais produtos quando próximo ao final da página (apenas scroll para baixo)
                if (!isLoading && hasNextPage && scrollingDown && scrollPosition >= documentHeight - 300) {
                  // Chegou próximo ao final da página, carregando mais produtos
                  loadMoreItems();
                }
              }
              
              // Função para carregar mais itens via AJAX
              function loadMoreItems() {
                if (isLoading || !hasNextPage) return;
                
                // Marcamos como carregando
                isLoading = true;
                
                // Mostrar indicador de carregamento
                if (loadingIndicator) loadingIndicator.classList.remove('hidden');
                loadingIndicator.style.display = 'flex';
                
                // Ocultar botão enquanto carrega
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';
                
                // Próxima página a carregar
                const nextPage = loadMoreBtn ? parseInt(loadMoreBtn.getAttribute('data-next-page') || (currentPage + 1).toString()) : currentPage + 1;
                
                // Construir URL com todos os parâmetros atuais, apenas alterando a página
                const url = new URL(window.location.href);
                url.searchParams.set('page', nextPage.toString());
                
                // Fazer requisição AJAX
                fetch(url.toString())
                  .then(response => response.text())
                  .then(html => {
                    // Criar um DOM temporário para extrair os produtos
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Obter os produtos da nova página
                    const newProductsGrid = doc.querySelector('.grid-cols-1.md\\:grid-cols-3');
                    const productCards = newProductsGrid ? newProductsGrid.querySelectorAll('a[href^="/produto/"]') : [];
                    
                    // Verificar se a próxima página tem o botão de carregar mais
                    const nextPageBtn = doc.getElementById('load-more-btn');
                    hasNextPage = !!nextPageBtn;
                    
                    // Atualizar o data-next-page se o botão existir
                    if (hasNextPage && loadMoreBtn && nextPageBtn) {
                      const nextPageNumber = nextPageBtn.getAttribute('data-next-page');
                      if (nextPageNumber) {
                        loadMoreBtn.setAttribute('data-next-page', nextPageNumber);
                      }
                    }
                    
                    // Verificar se precisamos atualizar a contagem nas categorias
                    // Observação: não substituímos filtros, apenas atualizamos os valores
                    const filtersContainer = document.querySelector('#filtersContainer');
                    if (filtersContainer) {
                      // Atualizar os contadores de categorias encontrando pelo nome da categoria
                      const categoryItems = filtersContainer.querySelectorAll('h3, li, ul, span'); 
                      
                      // Para cada item de categoria atual
                      categoryItems.forEach(item => {
                        const categoryName = item.textContent?.trim();
                        if (categoryName?.includes('Categorias') || 
                            categoryName?.includes('(') && categoryName?.includes(')')) {
                            
                          // Encontre a contagem do produto entre parênteses e atualize
                          if (categoryName.includes('(') && categoryName.includes(')')) {
                            // Extrai apenas o nome da categoria sem a contagem
                            const nameOnly = categoryName.split('(')[0].trim();
                            
                            // Procurar o elemento correspondente no novo DOM
                            const newItem = Array.from(doc.querySelectorAll('h3, li, ul, span')).find(el => {
                              const newText = el.textContent?.trim() || '';
                              return newText.startsWith(nameOnly) && newText.includes('(') && newText.includes(')');
                            });
                            
                            if (newItem) {
                              // Extrair a contagem do novo item
                              const countMatch = newItem.textContent?.match(/\((\d+)\)/);
                              if (countMatch && countMatch[1]) {
                                // Atualizar apenas a contagem, mantendo o nome
                                const newCount = `(${countMatch[1]})`;
                                item.textContent = item.textContent.replace(/\(\d+\)/, newCount);
                              }
                            }
                          }
                        }
                      });
                    }
                    
                    if (productCards.length > 0) {
                      // Adicionar os novos produtos ao grid sem duplicar
                      productCards.forEach(card => {
                        // Verificamos se o produto já está no grid (para evitar duplicações)
                        const productUrl = card.getAttribute('href');
                        const existingCard = productsGrid.querySelector(`a[href="${productUrl}"]`);
                        if (!existingCard) {
                          productsGrid.appendChild(card.cloneNode(true));
                        }
                      });
                      
                      // Atualizar contador de produtos mostrados
                      if (productsShownEl) {
                        const totalEl = doc.querySelector('#products-shown');
                        if (totalEl) {
                          productsShownEl.textContent = totalEl.textContent;
                        }
                      }
                      
                      // Atualizar URL sem recarregar a página, mas mantendo o valor de ordenação atual
                      const currentSort = new URL(window.location.href).searchParams.get('sort');
                      if (currentSort && !url.searchParams.has('sort')) {
                        url.searchParams.set('sort', currentSort);
                      }
                      window.history.replaceState({}, '', url.toString());
                      
                      // Atualizar página atual
                      currentPage = nextPage;
                    } else {
                      hasNextPage = false;
                    }
                    
                    // Esconder indicador de carregamento
                    if (loadingIndicator) {
                      loadingIndicator.style.display = 'none';
                    }
                    
                    // Mostrar ou esconder botão de carregar mais
                    if (loadMoreBtn) {
                      if (hasNextPage) {
                        loadMoreBtn.style.display = 'inline-flex';
                      } else {
                        loadMoreBtn.style.display = 'none';
                        
                        // Mostrar indicador de fim de resultados
                        const endOfResults = document.getElementById('end-of-results');
                        if (endOfResults) {
                          endOfResults.classList.remove('hidden');
                        }
                      }
                    }
                    
                    // Finalizar carregamento
                    isLoading = false;
                  })
                  .catch(error => {
                    console.error('Erro ao carregar mais produtos:', error);
                    
                    // Em caso de erro, mostrar botão novamente
                    if (loadMoreBtn) loadMoreBtn.style.display = 'inline-flex';
                    
                    // Esconder indicador de carregamento
                    if (loadingIndicator) loadingIndicator.style.display = 'none';
                    
                    // Finalizar carregamento
                    isLoading = false;
                  });
              }
              
              // Adicionar um throttle para não executar a função de scroll muitas vezes
              let scrollTimeout;
              function throttledScroll() {
                if (!scrollTimeout) {
                  scrollTimeout = setTimeout(function() {
                    checkScrollPosition();
                    scrollTimeout = null;
                  }, 200); // Executar no máximo a cada 200ms
                }
              }
              
              // Adicionamos o evento de scroll com throttle
              window.addEventListener('scroll', throttledScroll);
              
              // Verificamos uma vez depois que a página carrega
              setTimeout(checkScrollPosition, 1000);
            });
          </script>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Função para mostrar os filtros no mobile
    function showFilters() {
      document.getElementById('filtersContainer').classList.remove('hidden');
      document.getElementById('filtersContainer').classList.add('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
      document.getElementById('filtersOverlay').classList.remove('hidden');
      // Prevenir scroll do body
      document.body.style.overflow = 'hidden';
    }

    // Função para esconder os filtros no mobile
    function hideFilters() {
      document.getElementById('filtersContainer').classList.add('hidden');
      document.getElementById('filtersContainer').classList.remove('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
      document.getElementById('filtersOverlay').classList.add('hidden');
      // Restaurar scroll do body
      document.body.style.overflow = '';
    }

    // Detectar quando a tela é redimensionada para desktop
    function handleResize() {
      if (window.innerWidth >= 768) { // 768px é o breakpoint md no Tailwind
        document.getElementById('filtersContainer').classList.remove('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
        document.getElementById('filtersContainer').classList.remove('hidden');
        document.getElementById('filtersContainer').classList.add('block');
        document.getElementById('filtersOverlay').classList.add('hidden');
        document.body.style.overflow = '';
      } else {
        document.getElementById('filtersContainer').classList.add('hidden');
        document.getElementById('filtersContainer').classList.remove('block');
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function() {
      const toggleButton = document.getElementById('toggleFilters');
      const closeButton = document.getElementById('closeFilters');
      const overlay = document.getElementById('filtersOverlay');
      
      if (toggleButton) {
        toggleButton.addEventListener('click', showFilters);
      }
      
      if (closeButton) {
        closeButton.addEventListener('click', hideFilters);
      }
      
      if (overlay) {
        overlay.addEventListener('click', hideFilters);
      }
      
      // Lidar com redimensionamento de tela
      window.addEventListener('resize', handleResize);
      
      // Também consideramos a rotação do dispositivo
      window.addEventListener('orientationchange', handleResize);
    });
  </script>
</MarketplaceLayout>