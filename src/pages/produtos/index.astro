---
import Layout from '../../layouts/Layout.astro';
import MarketplaceLayout from '../../layouts/MarketplaceLayout.astro';
import ProductCard from '../../components/ui/ProductCard.astro';
import Rating from '../../components/ui/Rating.astro';
import Filters from '../../components/ui/Filters.astro';
import SimplifiedFilters from '../../components/ui/SimplifiedFilters.astro';
import categoryService from '../../services/categoryService';
import productService from '../../services/productService';

// Pegar parâmetros da URL
const { searchParams } = Astro.url;
const params = Astro.url.searchParams;

// Extrair parâmetros específicos da URL
const search = params.get('q') || '';
const minPrice = params.get('minPrice') || '';
const maxPrice = params.get('maxPrice') || '';
const sort = params.get('sort') || 'newest';
const page = parseInt(params.get('page') || '1');
const limit = parseInt(params.get('limit') || '12');

// Parâmetros para filtros de categorias
const selectedCategories = params.getAll('category') || [];

// Parâmetros para filtros de atributos
const attributeFilters = {};

// Encontrar todos os parâmetros de atributos (formato: attr_ID=VALOR)
for (const [key, value] of params.entries()) {
  if (key.startsWith('attr_')) {
    const attrId = key.replace('attr_', '');
    
    if (!attributeFilters[attrId]) {
      attributeFilters[attrId] = [];
    }
    
    attributeFilters[attrId].push(value);
  }
}

// Página atual
let pageTitle = 'Todos os Produtos';

// Se tiver categorias selecionadas, usar a primeira para o título
if (selectedCategories.length > 0) {
  const firstCategory = categoryService.getCategoryByCid(selectedCategories[0]);
  if (firstCategory) {
    pageTitle = firstCategory.name;
  }
}

// Se tiver pesquisa, mostrar no título
if (search) {
  pageTitle = `Resultados para "${search}"`;
}

// Opções para listar produtos
const options = {
  search,
  minPrice: minPrice ? parseFloat(minPrice) : undefined,
  maxPrice: maxPrice ? parseFloat(maxPrice) : undefined,
  sort,
  page,
  limit,
  attributeFilters
};

// Se tiver categorias selecionadas, adicionar ao filtro
if (selectedCategories.length > 0) {
  // Listar IDs das categorias selecionadas
  const categoryIds = [];
  
  for (const slug of selectedCategories) {
    const category = categoryService.getCategoryByCid(slug);
    if (category) {
      categoryIds.push(category.id);
    }
  }
  
  if (categoryIds.length > 0) {
    options.categoryIds = categoryIds;
  }
}

// Buscar produtos com os filtros aplicados
const { products, pagination } = productService.listProducts(options);

// Total de itens para exibição
const totalItems = pagination.total;

// Lista de categorias ativas (apenas as que têm produtos)
const activeCategories = categoryService.getActiveCategories();

// Obter os tipos de atributos disponíveis
const attributeTypes = productService.getAttributeTypesForFilters();

// Obter os valores disponíveis para cada tipo de atributo (considerando filtros aplicados)
const attributeValues = {};
for (const attributeType of attributeTypes) {
  attributeValues[attributeType.id] = productService.getAttributeValuesForType(
    attributeType.id, 
    // Passar mesmas opções para manter consistência nos filtros
    options
  );
}

// Obter filtro de preço
const priceRanges = productService.getPriceRangesForProducts(options);
---

<MarketplaceLayout title={pageTitle}>
  <div class="min-h-screen bg-gray-100 py-12">
    <div class="container mx-auto px-4">
      <!-- Filtros aplicados e controles superiores -->
      <div class="mb-6">
        <!-- Navegação e contador de produtos -->
        <div class="flex flex-wrap justify-between items-center mb-3">
          <nav class="mb-4 w-full md:mb-0 md:w-auto">
            <ol class="flex items-center text-[13px]">
              <li>
                <a href="/" class="text-gray-500 hover:text-gray-700 transition-colors">Home</a>
              </li>
              <li class="flex items-center">
                <span class="mx-1 text-gray-400">/</span>
                <a href="/produtos" class="text-gray-500 hover:text-gray-700 transition-colors">Produtos</a>
              </li>
              <li class="flex items-center">
                <span class="mx-1 text-gray-400">/</span>
                <span class="text-[#39c7bb] font-medium">{pageTitle}</span>
              </li>
            </ol>
          </nav>
          
          <p class="text-sm text-gray-500">
            <span class="font-medium">{totalItems}</span> produtos encontrados
          </p>
        </div>
        
        <!-- Seção de filtros ativos com fundo branco -->
        <div class="bg-white p-3 mb-5 flex flex-wrap justify-between items-center">
          <div class="flex flex-wrap items-center gap-2">
            <span class="text-sm text-gray-800 font-medium">Filtros:</span>
            
            {/* Categorias selecionadas */}
            {selectedCategories.map(catSlug => {
              const category = categoryService.getCategoryByCid(catSlug);
              if (!category) return null;
              
              return (
                <div class="inline-flex items-center px-3 py-1 text-xs bg-[#E0F7F4] text-[#39c7bb]">
                  <span>{category.name}</span>
                  <a 
                    href={(() => {
                      const url = new URL(Astro.url);
                      const cats = url.searchParams.getAll('category').filter(c => c !== catSlug);
                      url.searchParams.delete('category');
                      cats.forEach(c => url.searchParams.append('category', c));
                      return url.toString();
                    })()}
                    class="ml-1.5 focus:outline-none text-[#39c7bb]"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <line x1="18" y1="6" x2="6" y2="18"></line>
                      <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                  </a>
                </div>
              );
            })}
            
            {search && (
              <div class="inline-flex items-center px-3 py-1 text-xs bg-[#E0F7F4] text-[#39c7bb]">
                <span>Busca: {search}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('q');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {minPrice && (
              <div class="inline-flex items-center px-3 py-1 text-xs bg-[#E0F7F4] text-[#39c7bb]">
                <span>Preço Min: R$ {minPrice}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('minPrice');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {maxPrice && (
              <div class="inline-flex items-center px-3 py-1 text-xs bg-[#E0F7F4] text-[#39c7bb]">
                <span>Preço Max: R$ {maxPrice}</span>
                <a 
                  href={(() => {
                    const url = new URL(Astro.url);
                    url.searchParams.delete('maxPrice');
                    return url.toString();
                  })()}
                  class="ml-1.5 focus:outline-none text-[#39c7bb]"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                  </svg>
                </a>
              </div>
            )}
            
            {/* Filtros de atributos ativos */}
            {Object.entries(attributeFilters).map(([typeId, values]) => {
              const attributeType = productService.getAttributeTypesForFilters().find(t => t.id.toString() === typeId);
              if (!attributeType) return null;
              
              return values.map(value => {
                // Buscar o valor de exibição para este atributo
                let displayValue = value;
                let attrValues = [];
                
                if (attributeType.name.toLowerCase().includes('material')) {
                  attrValues = productService.getMaterialsForFilter(options);
                } else if (attributeType.name.toLowerCase().includes('cor') || attributeType.name.toLowerCase().includes('color')) {
                  attrValues = productService.getColorsForFilter(options);
                } else if (attributeType.name.toLowerCase().includes('tamanho') || attributeType.name.toLowerCase().includes('size')) {
                  attrValues = productService.getSizesForFilter(options);
                }
                
                const foundValue = attrValues.find(v => v.value === value);
                if (foundValue && foundValue.display_value) {
                  displayValue = foundValue.display_value;
                }
                
                return (
                  <div class="inline-flex items-center px-3 py-1 text-xs bg-[#E0F7F4] text-[#39c7bb]">
                    <span>{attributeType.display_name}: {displayValue}</span>
                    <a 
                      href={(() => {
                        const url = new URL(Astro.url);
                        const currentValues = url.searchParams.getAll(`attr_${typeId}`);
                        url.searchParams.delete(`attr_${typeId}`);
                        currentValues.filter(v => v !== value).forEach(v => {
                          url.searchParams.append(`attr_${typeId}`, v);
                        });
                        return url.toString();
                      })()}
                      class="ml-1.5 focus:outline-none text-[#39c7bb]"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                      </svg>
                    </a>
                  </div>
                );
              });
            })}
            
            {(selectedCategories.length > 0 || search || minPrice || maxPrice || Object.keys(attributeFilters).length > 0) && (
              <a 
                href="/produtos" 
                class="ml-auto text-xs text-[#39c7bb] hover:underline"
              >
                Limpar todos os filtros
              </a>
            )}
          </div>
          
          <div class="w-full md:w-auto mt-3 md:mt-0 flex gap-2">
            <select 
              id="sort-select"
              class="text-sm border border-gray-300 rounded px-2 py-1.5 focus:outline-none focus:ring-1 focus:ring-[#39c7bb]"
              onchange="window.location.href = new URL(`?${new URLSearchParams([...new URLSearchParams(window.location.search)].filter(([k]) => k !== 'sort'))}&sort=${this.value}`, window.location.href).toString()"
            >
              <option value="newest" selected={sort === 'newest'}>Mais recentes</option>
              <option value="price_asc" selected={sort === 'price_asc'}>Menor preço</option>
              <option value="price_desc" selected={sort === 'price_desc'}>Maior preço</option>
              <option value="name_asc" selected={sort === 'name_asc'}>A-Z</option>
              <option value="name_desc" selected={sort === 'name_desc'}>Z-A</option>
              <option value="featured" selected={sort === 'featured'}>Destaque</option>
            </select>
            
            <!-- Botão para exibir filtros no mobile -->
            <button 
              id="toggleFilters" 
              class="md:hidden flex items-center text-sm bg-white border border-gray-300 rounded px-3 py-1.5 focus:outline-none focus:ring-1 focus:ring-[#39c7bb]"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" />
              </svg>
              Filtros
            </button>
          </div>
        </div>
      </div>
      
      <!-- Filtros Simplificados para Mobile -->
      <div class="mb-6 md:hidden">
        <SimplifiedFilters
          categories={activeCategories}
          selectedCategories={selectedCategories}
          search={search}
        />
      </div>
      
      <!-- Conteúdo Principal - Layout de 2 colunas no desktop -->
      <div class="flex flex-col md:flex-row gap-8">
        <!-- Overlay para mobile (visível apenas quando os filtros estiverem abertos) -->
        <div id="filtersOverlay" class="hidden fixed inset-0 bg-black bg-opacity-50 z-40 md:hidden"></div>
        
        <!-- Filtros - Sidebar no desktop, escondida inicialmente no mobile -->
        <div id="filtersContainer" class="hidden md:block w-full md:w-[260px] md:sticky md:top-4 md:self-start">
          <div class="mb-4 relative">
            <!-- Botão fechar visível apenas no mobile -->
            <button 
              id="closeFilters" 
              class="absolute top-2 right-2 md:hidden bg-white rounded-full p-1 shadow-sm z-10"
              aria-label="Fechar filtros"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
            
            <Filters 
              search={search}
              minPrice={minPrice}
              maxPrice={maxPrice}
              selectedCategories={selectedCategories}
              selectedSort={sort}
              attributeFilters={attributeFilters}
              attributeTypes={attributeTypes}
              attributeValues={attributeValues}
              categories={activeCategories}
              priceRanges={priceRanges}
            />
          </div>
        </div>
        
        <!-- Produtos - Área principal -->
        <div class="w-full md:flex-1">
          <!-- Produtos Grid - 3 por linha no desktop, 1 no mobile com espaçamento vertical aumentado -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-x-4 gap-y-10 bg-white p-4">
            {products.length > 0 ? products.map((product) => (
              <a href={`/produto/${product.slug || product.id}`} class="block pt-7">
                <ProductCard 
                  product={{
                    id: product.id,
                    name: product.name,
                    price: product.price,
                    pricePromotional: product.compare_at_price,
                    discountPercent: product.compare_at_price ? 
                      Math.round(((product.compare_at_price - product.price) / product.compare_at_price) * 100) : null,
                    pieces: product.pieces || 0,
                    material: product.material || '',
                    image: product.mainImage || null,
                    ref: product.sku || product.id.toString()
                  }}
                  showBadges={true}
                />
              </a>
            )) : (
              <div class="col-span-3 py-8 text-center">
                <p class="text-gray-500">Nenhum produto encontrado com os filtros selecionados.</p>
                <a href="/produtos" class="mt-4 inline-block text-[#39c7bb] hover:underline">Limpar filtros</a>
              </div>
            )}
          </div>
          
          <!-- Botão e indicador de carregamento para scroll infinito -->
          <div class="py-4 text-center">
            <!-- Contador de produtos -->
            <span class="text-sm text-gray-500 block mb-4">
              Mostrando <span class="font-medium" id="products-shown">{Math.min(products.length, pagination.page * pagination.limit)}</span> de <span class="font-medium">{pagination.total}</span> produtos
            </span>
            
            <!-- Botão carregar mais para caso o scroll não seja detectado -->
            {pagination.hasNextPage && (
              <a 
                href={new URL(`?${new URLSearchParams({ ...Object.fromEntries(params), page: (page + 1).toString() })}`, Astro.url)} 
                id="load-more-btn" 
                class="mx-auto mb-4 bg-[#39c7bb] hover:bg-[#2ba090] text-white py-2 px-6 rounded-full inline-flex items-center gap-2"
              >
                <span>Carregar mais produtos</span>
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                </svg>
              </a>
            )}
            
            <!-- Loading indicator -->
            <div id="loading-indicator" class="py-4 flex-col items-center hidden">
              <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-[#39c7bb] mb-2"></div>
              <p class="text-gray-500 text-sm">Carregando mais produtos...</p>
            </div>
            
            <!-- Fim da lista quando todos os produtos forem carregados -->
            {!pagination.hasNextPage && products.length > 0 && (
              <div id="end-of-results" class="py-4">
                <p class="text-gray-500 text-sm">Todos os produtos foram carregados</p>
              </div>
            )}
          </div>
          
          <!-- Script para scroll infinito com AJAX (com fallback para botão) -->
          <script>
            document.addEventListener('DOMContentLoaded', function() {
              // Elementos necessários
              const loadMoreBtn = document.getElementById('load-more-btn');
              const loadingIndicator = document.getElementById('loading-indicator');
              const productsShownEl = document.getElementById('products-shown');
              const productsGrid = document.querySelector('.grid-cols-1.md\\:grid-cols-3');
              
              // Se não tiver botão de carregar mais, não precisamos fazer nada
              if (!loadMoreBtn || !productsGrid) return;
              
              // Variáveis para controle de estado
              let isLoading = false;
              let currentPage = parseInt(new URL(window.location.href).searchParams.get('page') || '1');
              let hasNextPage = true;
              
              // Adicionar evento de clique ao botão de carregar mais
              loadMoreBtn.addEventListener('click', function(e) {
                e.preventDefault(); // Impedir comportamento padrão de navegação
                loadMoreItems();
              });
              
              // Função que detecta quando o usuário está próximo do final da página
              function checkScrollPosition() {
                if (isLoading || !hasNextPage) return;
                
                const scrollPosition = window.scrollY + window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
                
                // Se estiver a 300px do final da página
                if (scrollPosition >= documentHeight - 300) {
                  console.log("Próximo ao final da página, carregando mais produtos...");
                  loadMoreItems();
                }
              }
              
              // Função para carregar mais itens via AJAX
              function loadMoreItems() {
                if (isLoading || !hasNextPage) return;
                
                // Marcamos como carregando
                isLoading = true;
                
                // Mostrar indicador de carregamento
                if (loadingIndicator) loadingIndicator.classList.remove('hidden');
                loadingIndicator.style.display = 'flex';
                
                // Ocultar botão enquanto carrega
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';
                
                // Próxima página a carregar
                const nextPage = currentPage + 1;
                
                // Construir URL com todos os parâmetros atuais, apenas alterando a página
                const url = new URL(window.location.href);
                url.searchParams.set('page', nextPage.toString());
                
                // Fazer requisição AJAX
                fetch(url.toString())
                  .then(response => response.text())
                  .then(html => {
                    // Criar um DOM temporário para extrair os produtos
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Obter os produtos da nova página
                    const newProductsGrid = doc.querySelector('.grid-cols-1.md\\:grid-cols-3');
                    const productCards = newProductsGrid ? newProductsGrid.querySelectorAll('a[href^="/produto/"]') : [];
                    
                    // Verificar se a próxima página tem o botão de carregar mais
                    const nextPageBtn = doc.getElementById('load-more-btn');
                    hasNextPage = !!nextPageBtn;
                    
                    // Verificar se precisamos atualizar a contagem nas categorias
                    // Observação: não substituímos filtros, apenas atualizamos os valores
                    const filtersContainer = document.querySelector('#filtersContainer');
                    if (filtersContainer) {
                      // Atualizar os contadores de categorias encontrando pelo nome da categoria
                      const categoryItems = filtersContainer.querySelectorAll('h3, li, ul, span'); 
                      
                      // Para cada item de categoria atual
                      categoryItems.forEach(item => {
                        const categoryName = item.textContent?.trim();
                        if (categoryName?.includes('Categorias') || 
                            categoryName?.includes('(') && categoryName?.includes(')')) {
                            
                          // Encontre a contagem do produto entre parênteses e atualize
                          if (categoryName.includes('(') && categoryName.includes(')')) {
                            // Extrai apenas o nome da categoria sem a contagem
                            const nameOnly = categoryName.split('(')[0].trim();
                            
                            // Procurar o elemento correspondente no novo DOM
                            const newItem = Array.from(doc.querySelectorAll('h3, li, ul, span')).find(el => {
                              const newText = el.textContent?.trim() || '';
                              return newText.startsWith(nameOnly) && newText.includes('(') && newText.includes(')');
                            });
                            
                            if (newItem) {
                              // Extrair a contagem do novo item
                              const countMatch = newItem.textContent?.match(/\((\d+)\)/);
                              if (countMatch && countMatch[1]) {
                                // Atualizar apenas a contagem, mantendo o nome
                                const newCount = `(${countMatch[1]})`;
                                item.textContent = item.textContent.replace(/\(\d+\)/, newCount);
                              }
                            }
                          }
                        }
                      });
                    }
                    
                    if (productCards.length > 0) {
                      // Adicionar os novos produtos ao grid sem duplicar
                      productCards.forEach(card => {
                        // Verificamos se o produto já está no grid (para evitar duplicações)
                        const productUrl = card.getAttribute('href');
                        const existingCard = productsGrid.querySelector(`a[href="${productUrl}"]`);
                        if (!existingCard) {
                          productsGrid.appendChild(card.cloneNode(true));
                        }
                      });
                      
                      // Atualizar contador de produtos mostrados
                      if (productsShownEl) {
                        const totalEl = doc.querySelector('#products-shown');
                        if (totalEl) {
                          productsShownEl.textContent = totalEl.textContent;
                        }
                      }
                      
                      // Atualizar URL sem recarregar a página
                      window.history.replaceState({}, '', url.toString());
                      
                      // Atualizar página atual
                      currentPage = nextPage;
                    } else {
                      hasNextPage = false;
                    }
                    
                    // Esconder indicador de carregamento
                    if (loadingIndicator) {
                      loadingIndicator.style.display = 'none';
                    }
                    
                    // Mostrar ou esconder botão de carregar mais
                    if (loadMoreBtn) {
                      if (hasNextPage) {
                        loadMoreBtn.style.display = 'inline-flex';
                      } else {
                        loadMoreBtn.style.display = 'none';
                        
                        // Mostrar indicador de fim de resultados
                        const endOfResults = document.getElementById('end-of-results');
                        if (endOfResults) {
                          endOfResults.classList.remove('hidden');
                        }
                      }
                    }
                    
                    // Finalizar carregamento
                    isLoading = false;
                  })
                  .catch(error => {
                    console.error('Erro ao carregar mais produtos:', error);
                    
                    // Em caso de erro, mostrar botão novamente
                    if (loadMoreBtn) loadMoreBtn.style.display = 'inline-flex';
                    
                    // Esconder indicador de carregamento
                    if (loadingIndicator) loadingIndicator.style.display = 'none';
                    
                    // Finalizar carregamento
                    isLoading = false;
                  });
              }
              
              // Adicionamos o evento de scroll
              window.addEventListener('scroll', checkScrollPosition);
              
              // Verificamos uma vez depois que a página carrega
              setTimeout(checkScrollPosition, 1000);
            });
          </script>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Função para mostrar os filtros no mobile
    function showFilters() {
      document.getElementById('filtersContainer').classList.remove('hidden');
      document.getElementById('filtersContainer').classList.add('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
      document.getElementById('filtersOverlay').classList.remove('hidden');
      // Prevenir scroll do body
      document.body.style.overflow = 'hidden';
    }

    // Função para esconder os filtros no mobile
    function hideFilters() {
      document.getElementById('filtersContainer').classList.add('hidden');
      document.getElementById('filtersContainer').classList.remove('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
      document.getElementById('filtersOverlay').classList.add('hidden');
      // Restaurar scroll do body
      document.body.style.overflow = '';
    }

    // Detectar quando a tela é redimensionada para desktop
    function handleResize() {
      if (window.innerWidth >= 768) { // 768px é o breakpoint md no Tailwind
        document.getElementById('filtersContainer').classList.remove('fixed', 'inset-y-0', 'left-0', 'w-[80%]', 'max-w-xs', 'z-50', 'bg-white', 'shadow-xl', 'overflow-y-auto');
        document.getElementById('filtersContainer').classList.remove('hidden');
        document.getElementById('filtersContainer').classList.add('block');
        document.getElementById('filtersOverlay').classList.add('hidden');
        document.body.style.overflow = '';
      } else {
        document.getElementById('filtersContainer').classList.add('hidden');
        document.getElementById('filtersContainer').classList.remove('block');
      }
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function() {
      const toggleButton = document.getElementById('toggleFilters');
      const closeButton = document.getElementById('closeFilters');
      const overlay = document.getElementById('filtersOverlay');
      
      if (toggleButton) {
        toggleButton.addEventListener('click', showFilters);
      }
      
      if (closeButton) {
        closeButton.addEventListener('click', hideFilters);
      }
      
      if (overlay) {
        overlay.addEventListener('click', hideFilters);
      }
      
      // Lidar com redimensionamento de tela
      window.addEventListener('resize', handleResize);
      
      // Também consideramos a rotação do dispositivo
      window.addEventListener('orientationchange', handleResize);
    });
  </script>
</MarketplaceLayout>